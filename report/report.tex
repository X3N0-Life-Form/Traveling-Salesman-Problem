\documentclass[a4paper,10pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[francais]{babel}
\usepackage{hyperref}

% Title Page
\title{Opérateurs de recherche et stratégies d'exploration} %Traveling Salesman Problem
\author{Adrien DROGUET}
\date{Avril - Juin 2014}

\pagestyle{plain}

\begin{document}
\maketitle
%customiser page de titre
%ajouter nom de l'encadrant
%logo univ

\tableofcontents
\pagebreak

\section{Définitions}
\begin{itemize}
 \item Problème : Ensemble de villes devant être parcourues.
 \item Voisinage : Chemin parcourant toutes les villes sans répétition. Solution au problème du voyageur de commerce.
 \item Voisin améliorant : Chemin voisin d'une solution X, dont le coût est inférieur au coût de X.
 \item Recherche locale : Exploration exhaustive de l'ensemble des voisins d'une solution donnée.
 Coûteux en temps d'exécution.
 \item Relation de voisinage : Fonction permettant de passer d'un voisinage à un autre.
 \begin{itemize}
  \item Swap : Échange la position de deux villes dans un chemin.
  \item Insert : Insert une ville avant une autre.
  \item Reverse : Inverse un sous section d'un chemin.
 \end{itemize}
 \item Stratégie de sélection : Détermine la manière dont on choisit un voisin en recherche locale.
 \begin{itemize}
  \item First Fit : Choisir le premier voisin améliorant trouvé.
  \item Best Fit : Choisir le meilleur améliorant trouvé.
  \item Worst Fit : Choisir le moins bon améliorant trouvé.
 \end{itemize}
\end{itemize}


\section{Introduction}

\paragraph{} % sujet
  Le but de ce projet est d'étudier l'efficacité de différents opérateurs de recherche et stratégies applicables
à la résolution de ce problème en recherche locale. Suite à l'étude des résultats de ces différents algorithmes
et stratégies, le projet vise la mise en place de méthodes permettant d'effectuer une recherche partielle capable
d'obtenir des résultats comparables à ceux d'une recherche locale à un coût moindre en temps de calcul.

\paragraph{}
  Le voyageur de commerce est un problème bien connu dans le milieu informatique : pour un ensemble de villes,
minimiser la distance requise qu'un individu doit parcourir afin de visiter chaque ville. De nombreuses études
ont été menées sur ce sujet et une quantité significative d'algorithmes de résolution ont été écrit au fil des
ans. Pour cette raison, cette problématique forme un cadre intéressant pour l'analyse de l'efficacité des différents
opérateurs relationnels que l'ont cherche à étudier.

\paragraph{} % ressources utilisées
  Pour référence, nous avons utilisé les problèmes fourni par
\href{https://www.iwr.uni-heidelberg.de/groups/comopt/software/TSPLIB95/}{TSPLIB}
- une bibliothèque d'échantillons d'instances pour le TSP (et autres problèmes liés) provenant de diverses sources
et de types variés. Dans notre cas, nous nous sommes confiné à des problèmes symétriques à deux dimensions, avec des
distances entières ou réelles.


%%%%%%%%%%%%%%%%%%%%
% Partie Recherche %
%%%%%%%%%%%%%%%%%%%%
\part{Recherche}
\chapter{Recherche locale}
\section{Implémentation des algorithmes}
\subsection{Relations de voisinage}

\paragraph{}
  Après avoir établit une représentation satisfaisante et un système de lecture des données fonctionnel (voir partie
développement, sous-section représentation des données), nous avons défini trois types de mouvements, ou relation de
voisinage à appliquer à une solution : l'échange (Swap), l'insertion (Insert) et l'inversion (Reverse).

\paragraph{}
Afin d'éviter de recalculer le coût d'une solution (c'est à dire la distance que le voyageur doit parcourir
pour un chemin donné), à chacune de ces relations est associé une fonction de calcul de coût potentielle.
Celle-ci prend en paramètre les villes sur lesquels seront appliqués les déplacements, et effectue les calculs
aux points de rupture du chemin modifié.
% insérer schéma types de déplacements + points de rupture
% reprendre comme exemple 0123456789


\subsection{Stratégies de sélection d'un voisinage}

\paragraph{}
  Une fois que l'on dispose d'une fonction permettant de calculer le voisinage d'une solution donnée, il faut déterminer
une stratégie d'amélioration à appliquer. Nous avons retenu trois stratégies distinctes à appliquer à notre recherche
locale : choisir le premier voisin améliorant que l'on trouve (First Fit), choisir le meilleur voisin améliorant après
avoir parcouru l'ensemble des voisins possibles (Best Fit), ou bien choisir le voisin améliorant le moins possible la
solution actuelle (Worst Fit).
% schémas d'exemples


\subsection{Lancement}

\paragraph{}
  Suite au parsage d'un TSP particulier, notre programme s'efforce d'appliquer chacune des relations et chacune
des stratégies spécifiées l'une après l'autre, en partant éventuellement du même point de départ. Le voisinage de
départ est généré aléatoirement à partir des données du problème. Chaque pas est exploré de manière aléatoire, bien
que dans le cas des stratégies Best Fit et Worst Fit, on va chercher (dans un premier temps) à explorer l'ensemble
des voisins possibles.

\paragraph{}
En fin d'exécution, un résumé des résultats obtenus est affiché en console.

\begin{figure}[h]
Run Results for a280:
 \begin{center}
Run Data: Relation=Reverse;	Strategy=First Fit;	starting cost=34194,	end cost=3026;	depth=1182;	run time= 0.448 sec\linebreak
Run Data: Relation=Reverse;	Strategy=Best Fit;	starting cost=34194,	end cost=2935;	depth=297;	run time= 9.652 sec\linebreak
Run Data: Relation=Reverse;	Strategy=Worst Fit;	starting cost=34194,	end cost=3010;	depth=29699;	run time= 22 min 32.312 sec\linebreak
 \end{center}
  \label{a280-sample-results}
  \caption{Résumé de fin d'exécution - format texte}
\end{figure}

\paragraph{}
Instances utilisées (par ordre de lancement) :
\begin{itemize}
  \item \textbf{a280.tsp} : Instance principalement utilisée par les tests unitaires, d'une taille respectable, mais pas excessive.
  \item \textbf{att48.tsp} : Instance de petite taille, utilisée lors de tests manuels rapide ou en débuggage.
  \item \textbf{berlin52.tsp} : Instance de petite taille.
  \item \textbf{ali535.tsp} : Instance de grande taille, beaucoup utilisée étalon lorsque l'on cherche à améliorer les temps
d'exécution.
  \item \textbf{ch130.tsp} : Instance de taille moyenne.
  \item \textbf{ch150.tsp} : Instance de taille moyenne.
  \item \textbf{burma14.tsp} : Instance de très petite taille.
  \item \textbf{bier127.tsp} : Instance de taille moyenne, parfois substituée à a280 dans les tests.
  \item \textbf{brd14051.tsp} : Instance de taille excessive, seule la stratégie First Fit met un temps ``raisonnable''
à atteindre un optimum local. Best Fit et Worst Fit n'ont jamais été testé sur cette instance.
\end{itemize}

\pagebreak
\section{Analyse et comparaison de l'efficacité des algorithmes}
\subsection{Enregistrement des résultats}

\paragraph{}
  Après chaque exécution, on en enregistre les résultats dans des fichiers sous forme textuelle. On distingue deux
types de fichiers de sortie. D'une part les *.results sont équivalents à la sortie console en fin de programme et
fournissent un résumé facile à lire pour les humain.
\paragraph{}
  D'autre part, les *.csv contiennent les mêmes données enregistrées au format Comma Separated Value, ie. valeurs
séparées par virgule, chaque ligne correspondant à un couple Relation/Stratégie. Typiquement, le contenu de ces 
fichiers est concatené dans un fichier résumé, qui peut alors être copié tel quel dans un tableur type Microsoft
Excel ou Libre Office Calc. Voir en annexe pour description plus approfondie du tableur utilisé.

\begin{figure}[h]
  \begin{tabular}{ccccccc}
    a280, &Reverse, &First Fit, &34194, &3026, &1182, &0.448\\
    a280, &Reverse, &Best Fit,  &34194, &2935, &297,  &9.652\\
    a280, &Reverse, &Worst Fit, &34194, &3010, &29699,&1352.312\\
  \end{tabular}
  \label{a280-sample-csv}
  \caption{Résumé de fin d'exécution - format .csv}
\end{figure}

% insérer screen de recap.ods

\subsection{Efficacité constatée}

\begin{figure}[h]
  \begin{tabular}{ccrrr}
    \textbf{Opérateur}& \textbf{Stratégie}& \textbf{Coût Moyen}& \textbf{Temps d'exécution}& \textbf{Profondeur}\\
%   Opérateur&	Stratégie&	Coût Moyen&	Temps d'exécution&	Profondeur\\
    Swap&	First Fit&	35 404,39&	107,186&		150 717\\
    Swap&	Best Fit&	37 313,41&	1 198,021&		46 680\\
    Swap&	Worst Fit&	33 743,71&	63 440,385&		3 275 847\\
    Insert&	First Fit&	28 531,77&	55,669&			144 553\\
    Insert&	Best Fit&	29 643,06&	233,594&		22 209\\
    Insert&	Worst Fit&	28 420,68&	65 041,299&		4 667 846\\
    Reverse&	First Fit&	25 823,20&	88,784&			148 971\\
    Reverse&	Best Fit&	25 344,58&	409,759&		16 198\\
    Reverse&	Worst Fit&	26 349,78&	58 323,618&		3 912 314\\
  \end{tabular}
  \label{recap-general}
  \caption{Exemple de données générales recueillies après 40 exécutions sur chaque instance}
\end{figure}

% résultats spécifiques (ne pas tous les mettre, en envoyer dans annexe)
%ALSO: utiliser couleur plutôt que underline

\begin{center}
  \begin{figure}[h]
    \begin{tabular}{lrrr}
	&	    \textbf{First Fit}&	\textbf{Best Fit}&	\textbf{Worst Fit}\\
      \textbf{Swap}&	7 653,780&		8 516,976&	\underline{6 437,415}\\
      \textbf{Insert}&	5 435,000&		5 674,415&	\underline{4 969,829}\\
      \textbf{Reverse}&	4 508,780&	\underline{4 346,805}&	4 532,195\\
    \end{tabular}
    \label{a280-results}
    \caption{Résultats moyens pour le TSP a280}
  \end{figure}
\end{center}

\begin{center}
  \begin{figure}[h]
    \begin{tabular}{lrrr}
      &		\textbf{First Fit}&	\textbf{Best Fit}&	\textbf{Worst Fit}\\
      \textbf{Swap}&	3 200,600&	3 432,550&		2 662,600\\
      \textbf{Insert}&	2 516,450&	3 299,950&		2 359,950\\
      \textbf{Reverse}&	861,250&	861,350&		861,400\\
    \end{tabular}
    \label{ali535-results}
    \caption{Résultats moyens pour le TSP ali535}
  \end{figure}
\end{center}

\begin{center}
  \begin{figure}[h]
    \begin{tabular}{lrrr}
      &		\textbf{First Fit}&	\textbf{Best Fit}&	\textbf{Worst Fit}\\
      \textbf{Swap}&	53 327,317&	55 026,098&		51 228,220\\
      \textbf{Insert}&	44 155,293&	44 656,390&		43 567,049\\
      \textbf{Reverse}&	40 788,024&	40 212,732&		40 826,512\\
    \end{tabular}
    \label{att48-results}
    \caption{Résultats moyens pour le TSP att48}
  \end{figure}
\end{center}

\begin{center}
  \begin{figure}[h]
    \begin{tabular}{lrrr}
      &		\textbf{First Fit}&	\textbf{Best Fit}&	\textbf{Worst Fit}\\
      \textbf{Swap}&	24,683&		25,756&			26,098\\
      \textbf{Insert}&	26,098&		24,585&			24,732\\
      \textbf{Reverse}&	23,659&		23,707&			24,390\\
    \end{tabular}
    \label{burma14-results}
    \caption{Résultats moyens pour le TSP burma14}
  \end{figure}
\end{center}

%Conclusion

\chapter{Analyse d'efficacité et espérance d'amélioration}

\paragraph{}
  Suite à l'étude préliminaire de l'efficacité de chacun des relations et stratégies, on a cherché à étudier
plus en détail le comportement de ces algorithmes en cours d'exécution.

\section{Enregistrement du déroulement de l'algorithme pas à pas}

\paragraph{}
  Avant toute chose, il a fallu concevoir de nouvelles structures capable de représenter l'état de notre programme
à un instant t. Ensuite, ces classes ont été greffé au code existant sans en modifier le comportement. Finalement,
nous avons choisi d'enregistrer chaque étape, chaque ``pas'' ligne par ligne dans un fichier texte. Une fois encore,
nous utilisons le format .csv afin de pouvoir aisément transférer ces données dans un tableur au besoin.

\paragraph{}
  Via le tableur, nous avons pu établir des graphe retraçant l'historique de chaque exécution. La contrepartie de
cette méthode est la relative difficulté à comparer de nombreux résultats cote à cote, le logiciel n'étant pas
bien adapté pour traiter de tels volumes de données de manière dynamique.

\begin{figure}[ht]
  \begin{tabular}{cccccc}
    Reverse,&First Fit,&[1;4[,&[4;16[,&[16;64[,&[64;281[,\\
    Reverse,&First Fit,&0,    &0,     &1,      &1,\\
    Reverse,&First Fit,&0,    &0,     &2,      &1,\\
    Reverse,&First Fit,&0,    &0,     &2,      &2,\\
    Reverse,&First Fit,&0,    &0,     &2,      &3,\\
    Reverse,&First Fit,&0,    &0,     &2,      &4,\\
    Reverse,&First Fit,&0,    &0,     &2,      &5,\\
    Reverse,&First Fit,&0,    &0,     &3,      &5,\\
    Reverse,&First Fit,&0,    &0,     &3,      &6,\\
    Reverse,&First Fit,&0,    &0,     &3,      &7,\\
    Reverse,&First Fit,&0,    &0,     &3,      &8,\\
  \end{tabular}
  \label{a280-sample-interval-simple}
  \caption{Extrait simplifié d'historique d'exécution}
\end{figure}

\pagebreak
\section{Analyse des résultats}

\section{Espérance d'amélioration - Implémentation d'un système de décision}

\paragraph{}
%but=réduire espace de recherche

\subsection{Piste 1 : probabilité de considérer un voisin}
\subsubsection{Idée}
%en fonction de son intervalle
%

\subsubsection{Problèmes}


\subsection{Piste 2 : Trier les intervalles de considération}
\subsubsection{Idée}
%+ proba de base fonction de l'intervalle

\subsubsection{Problèmes}

\subsection{Piste 3 : Échantillonnage acceptable (non implémenté)}
\subsubsection{Idée}
%probabilité d'arrêter la recherche en fonction du nombre de voisins explorés et de passer au niveau suivant

\subsubsection{Problèmes potentiels}


%%%%%%%%%%%%%%%%%%%%
% Partie technique %
%%%%%%%%%%%%%%%%%%%%
\part{Développement}
\chapter{Structure de l'application}
\section{Organisation des Classes}
\subsection{Représentation des données}
%core + parsage

\subsection{Compartimentalisation des algorithmes}
%relation & stratégie

\subsection{Exécution du programme}
%main, parser & runner

\subsection{Analyse Comportementale}
%interval stuff

\subsection{Recherche partielle}
%choice


\chapter{Déroulement du projet}
\section{Organisation}
\subsection{Standards auto-imposés}

\subsection{Gestion de version}

\subsection{Contrôle de non-régression}
%tests unitaires
%retro compatibilité

\subsection{Profiling et Optimisation}
%valgrind, callgrind & autre

\subsection{Optimisation}

\section{Difficultés techniques}

\part{Conclusion}
\section{Conclusion}


\section{Informations complémentaires}
%bibliographie
%licence
%repo github


\end{document}          
